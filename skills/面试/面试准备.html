<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试准备 | 琅玕的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="个人编程技术分享">
    
    <link rel="preload" href="/blog/assets/css/0.styles.671fbdd0.css" as="style"><link rel="preload" href="/blog/assets/js/app.e95f8842.js" as="script"><link rel="preload" href="/blog/assets/js/3.08356745.js" as="script"><link rel="preload" href="/blog/assets/js/54.c7097067.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.acf34bf9.js"><link rel="prefetch" href="/blog/assets/js/11.fef1fa27.js"><link rel="prefetch" href="/blog/assets/js/12.c774ebf1.js"><link rel="prefetch" href="/blog/assets/js/13.bf6af2da.js"><link rel="prefetch" href="/blog/assets/js/14.7b60b543.js"><link rel="prefetch" href="/blog/assets/js/15.5515032c.js"><link rel="prefetch" href="/blog/assets/js/16.3c0cd04c.js"><link rel="prefetch" href="/blog/assets/js/17.80206c1e.js"><link rel="prefetch" href="/blog/assets/js/18.e5e2c85c.js"><link rel="prefetch" href="/blog/assets/js/19.2f69b079.js"><link rel="prefetch" href="/blog/assets/js/2.9988781b.js"><link rel="prefetch" href="/blog/assets/js/20.7a923a3b.js"><link rel="prefetch" href="/blog/assets/js/21.d81d0001.js"><link rel="prefetch" href="/blog/assets/js/22.2fe5ab39.js"><link rel="prefetch" href="/blog/assets/js/23.99bc8ff5.js"><link rel="prefetch" href="/blog/assets/js/24.1fcf63f7.js"><link rel="prefetch" href="/blog/assets/js/25.a5536fa6.js"><link rel="prefetch" href="/blog/assets/js/26.e2fb222c.js"><link rel="prefetch" href="/blog/assets/js/27.03389df0.js"><link rel="prefetch" href="/blog/assets/js/28.4b72525f.js"><link rel="prefetch" href="/blog/assets/js/29.03a090ad.js"><link rel="prefetch" href="/blog/assets/js/30.87f31b47.js"><link rel="prefetch" href="/blog/assets/js/31.c639ea6f.js"><link rel="prefetch" href="/blog/assets/js/32.795ca246.js"><link rel="prefetch" href="/blog/assets/js/33.647699a4.js"><link rel="prefetch" href="/blog/assets/js/34.2909ac9c.js"><link rel="prefetch" href="/blog/assets/js/35.b5d4b577.js"><link rel="prefetch" href="/blog/assets/js/36.474a6bcb.js"><link rel="prefetch" href="/blog/assets/js/37.4590b450.js"><link rel="prefetch" href="/blog/assets/js/38.1cfbe263.js"><link rel="prefetch" href="/blog/assets/js/39.4c159456.js"><link rel="prefetch" href="/blog/assets/js/4.1c4b8134.js"><link rel="prefetch" href="/blog/assets/js/40.c52cb9af.js"><link rel="prefetch" href="/blog/assets/js/41.f77d6a1f.js"><link rel="prefetch" href="/blog/assets/js/42.c45631ae.js"><link rel="prefetch" href="/blog/assets/js/43.44644811.js"><link rel="prefetch" href="/blog/assets/js/44.c40d24aa.js"><link rel="prefetch" href="/blog/assets/js/45.0c1b86d7.js"><link rel="prefetch" href="/blog/assets/js/46.85dd5346.js"><link rel="prefetch" href="/blog/assets/js/47.a52d8379.js"><link rel="prefetch" href="/blog/assets/js/48.dfaedde6.js"><link rel="prefetch" href="/blog/assets/js/49.604893e5.js"><link rel="prefetch" href="/blog/assets/js/5.b41d7dd5.js"><link rel="prefetch" href="/blog/assets/js/50.228c7e1a.js"><link rel="prefetch" href="/blog/assets/js/51.7a95ac4e.js"><link rel="prefetch" href="/blog/assets/js/52.79ff7d2e.js"><link rel="prefetch" href="/blog/assets/js/53.7aeffa50.js"><link rel="prefetch" href="/blog/assets/js/6.31dc016b.js"><link rel="prefetch" href="/blog/assets/js/7.96c397d1.js"><link rel="prefetch" href="/blog/assets/js/8.e97d6841.js"><link rel="prefetch" href="/blog/assets/js/9.66ed6f07.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.671fbdd0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">琅玕的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  学习
</a></div><div class="nav-item"><a href="/blog/share/" class="nav-link">
  资源分享
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  学习
</a></div><div class="nav-item"><a href="/blog/share/" class="nav-link">
  资源分享
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/skills/IoT" class="sidebar-heading clickable"><span>IoT</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/IoT/基于NodeMcu的智慧生态农业系统设计.html" class="sidebar-link">基于NodeMcu的智慧生态农业系统设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/skills/JavaSE" class="sidebar-heading clickable"><span>JavaSE</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/JavaSE/File类和IO流.html" class="sidebar-link">File类和IO流</a></li><li><a href="/blog/skills/JavaSE/Java基础手写笔记.html" class="sidebar-link">/skills/JavaSE/Java基础手写笔记.html</a></li><li><a href="/blog/skills/JavaSE/Java常用API.html" class="sidebar-link">Java常用API</a></li><li><a href="/blog/skills/JavaSE/Thread.html" class="sidebar-link">Thread</a></li><li><a href="/blog/skills/JavaSE/内部类.html" class="sidebar-link">内部类</a></li><li><a href="/blog/skills/JavaSE/反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/skills/DSDB" class="sidebar-heading clickable"><span>DSDB</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/DSDB/Collection.html" class="sidebar-link">Java的集合类</a></li><li><a href="/blog/skills/DSDB/HTTP&amp;Tomcat.html" class="sidebar-link">HTTP&amp;Tomcat</a></li><li><a href="/blog/skills/DSDB/JDBC.html" class="sidebar-link">JDBC</a></li><li><a href="/blog/skills/DSDB/Map.html" class="sidebar-link">Map</a></li><li><a href="/blog/skills/DSDB/Maven.html" class="sidebar-link">Maven</a></li><li><a href="/blog/skills/DSDB/Mybatis.html" class="sidebar-link">Mybatis</a></li><li><a href="/blog/skills/DSDB/SQL.html" class="sidebar-link">SQL</a></li><li><a href="/blog/skills/DSDB/Stream.html" class="sidebar-link">Stream</a></li><li><a href="/blog/skills/DSDB/前端.html" class="sidebar-link">前端</a></li><li><a href="/blog/skills/DSDB/数据库索引.html" class="sidebar-link">数据库索引</a></li><li><a href="/blog/skills/DSDB/连接池.html" class="sidebar-link">/skills/DSDB/连接池.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/skills/JavaEE&amp;Spring" class="sidebar-heading clickable"><span>JavaEE&amp;Spring</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/JavaEE&amp;Spring/MyBatis-Spring.html" class="sidebar-link">MyBatis - Spring、Spring事务</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/Request&amp;Response.html" class="sidebar-link">Request &amp; Response</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/Servlet.html" class="sidebar-link">Servlet</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/SpringAOP.html" class="sidebar-link">Spring AOP</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/SpringBoot.html" class="sidebar-link">SpringBoot</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/SpringIOC.html" class="sidebar-link">Spring IOC</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/SpringMVC.html" class="sidebar-link">Spring MVC</a></li><li><a href="/blog/skills/JavaEE&amp;Spring/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/skills/微服务" class="sidebar-heading clickable"><span>微服务</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/微服务/ElasticSearch.html" class="sidebar-link">ElasticSearch</a></li><li><a href="/blog/skills/微服务/Gateway.html" class="sidebar-link">Gateway</a></li><li><a href="/blog/skills/微服务/MapStruct.html" class="sidebar-link">MapStruct</a></li><li><a href="/blog/skills/微服务/Mybatis-Plus.html" class="sidebar-link">Mybatis-Plus</a></li><li><a href="/blog/skills/微服务/Nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/blog/skills/微服务/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/blog/skills/微服务/Redis在Java项目中的使用.html" class="sidebar-link">Redis在Java项目中的使用</a></li><li><a href="/blog/skills/微服务/RocketMQ.html" class="sidebar-link">RocketMQ</a></li><li><a href="/blog/skills/微服务/SpringCloud.html" class="sidebar-link">SpringCloud</a></li><li><a href="/blog/skills/微服务/微服务.html" class="sidebar-link">微服务</a></li><li><a href="/blog/skills/微服务/微服务架构和单体架构.html" class="sidebar-link">微服务架构和单体架构</a></li><li><a href="/blog/skills/微服务/秒杀.html" class="sidebar-link">秒杀</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/skills/面试" class="sidebar-heading clickable open"><span>面试</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/面试/面经.html" class="sidebar-link">面经</a></li><li><a href="/blog/skills/面试/面试准备.html" class="active sidebar-link">面试准备</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#自我介绍" class="sidebar-link">自我介绍</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#技术总结" class="sidebar-link">技术总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_1-se" class="sidebar-link">1. SE</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_2-集合类" class="sidebar-link">2. 集合类</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_3-mysql、redis" class="sidebar-link">3. MySQL、Redis</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_4-spring" class="sidebar-link">4. Spring</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_5-springmvc" class="sidebar-link">5. SpringMVC</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_6-mybatis、mybatis-plus" class="sidebar-link">6. MyBatis、MyBatis-Plus</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_7-mapstruct" class="sidebar-link">7. MapStruct</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_8-springboot" class="sidebar-link">8. SpringBoot</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_9-springcloud" class="sidebar-link">9. SpringCloud</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_10-elasticsearch" class="sidebar-link">10. ElasticSearch</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_11-minio" class="sidebar-link">11. MinIO</a></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#_12-rocketmq" class="sidebar-link">12. RocketMQ</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/skills/面试/面试准备.html#项目介绍" class="sidebar-link">项目介绍</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试准备"><a href="#面试准备" class="header-anchor">#</a> 面试准备</h1> <h2 id="自我介绍"><a href="#自我介绍" class="header-anchor">#</a> 自我介绍</h2> <ol><li><p>基本信息、爱好</p></li> <li><p>工作经历</p></li> <li><p>技术介绍</p> <p>聊毕设</p> <p>聊学习能力：语言、框架、以用促学、学以致用</p> <p>聊项目</p></li></ol> <p><strong>开场白</strong>：开始时，先向面试官致以礼貌的问候，并简单介绍自己。例如：</p> <p>&quot;您好，我是[姓名]，非常荣幸有机会参加面试。&quot;</p> <p><strong>学习背景</strong>：介绍自己的教育背景和相关学习经历。包括所学专业、学校、学位等。例如：</p> <p>我本科就读于[学校名称]，[专业名称]。在大学期间，我学习了Java编程语言，并通过相关课程和项目获得了坚实的编程基础。获奖经历。</p> <p><strong>工作经验</strong>：简要介绍自己的工作经验，包括公司名称、职位和工作内容。重点突出与应聘职位相关的经验和成就。例如：</p> <p>我有一年的Java后端开发经验，在[公司名称]担任Java开发工程师的职位。我参与了多个项目的开发和维护，负责设计和实现后端功能，并与前端团队紧密合作，确保系统的稳定性和性能优化。我在项目中成功解决了一些挑战，如优化数据库查询性能和引入缓存机制，获得了积极的反馈。</p> <p><strong>技术能力</strong>：列举自己掌握的关键技术和工具，并说明在这些方面的经验和熟练程度。例如：</p> <p>我掌握Idea、maven、git等常见的项目开发和管理工具。熟悉使用关系型数据库MySQL和非关系型数据库Redis。掌握Spring全家桶的使用，熟悉使用MyBatis-Plus提供的基本的增删改查接口和条件构造器，熟悉使用ElasticSearch实现搜索功能。</p> <p>我能够快速地接受新的技术，可以做到“以用促学，学以致用”。</p> <p><strong>项目经验</strong>：提及参与过的具体项目，并简要介绍自己在项目中承担的角色和所取得的成就。例如：</p> <p>最近的一个项目是[项目名称]，我们团队负责开发一个电子商务平台。我在项目中负责设计和实现用户管理和订单处理模块，通过使用Spring框架和数据库优化技术，成功提高了系统的性能和响应速度。这个项目得到了客户的高度评价，并在上线后取得了良好的用户反馈。</p> <p><strong>总结与展望</strong>：简要总结自己的优势和对未来的期望，并表达对公司的兴趣和动机。例如：</p> <p>总的来说，我对Java后端开发充满热情，并持续学习和探索新技术。我希望能够加入贵公司，与优秀的团队合作，共同推动产品的发展和创新。我相信我的技术能力和团队合作能力能够为公司带来价值。</p> <p><strong>结尾</strong>：感谢面试官的时间和考虑，并表达期待进一步交流的意愿。例如：</p> <p>非常感谢您给我这次面试的机会，我非常期待进一步的交流。谢谢！</p> <h2 id="技术总结"><a href="#技术总结" class="header-anchor">#</a> 技术总结</h2> <h3 id="_1-se"><a href="#_1-se" class="header-anchor">#</a> 1. SE</h3> <p>面向对象编程思想、IO 流、多线程、注解反射、Stream 流、Lambda 表达式。</p> <p><strong>面对对象</strong>：</p> <p><strong>封装</strong>：封装可以被认为是一种保护屏障，防止类的代码和数据被外部类定义的代码随机访问。</p> <p>实现封装的步骤：</p> <ul><li>修改属性的可见性来限制对属性的访问(一般限制为private)</li> <li>对每个属性提供对外的公共方法访问，也就是创建一对赋取值的方法，用于对私有属性的访问(get/set方法)</li></ul> <p><strong>继承</strong>：一个类可以继承另一个类，子类可以继承父类的属性和方法，并可以在此基础上进行扩展和修改。这样，多个类重复使用到的代码(属性和方法)就可以抽取成一个父类，然后这些类继承这个父类。提高了开发效率，减少了维护成本。</p> <p><strong>多态</strong>：同一个行为具有多个不同的表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同的操作。也就是说，每一个实例对应的子类对父类同一个方法重写的结果都不一样。</p> <p>举例：彩色打印机和黑白打印机，他们都实现了打印机这个接口，当他们打印同一张彩色照片的时候，他们分别打印出彩色照片和黑白照片。</p> <p>多态存在的三个必要条件</p> <ul><li>继承</li> <li>重写</li> <li>父类引用指向子类对象</li></ul> <p>多态的优点：</p> <ul><li>消除类型之间的耦合</li> <li>可替换性</li> <li>可扩充性</li> <li>接口性</li> <li>灵活性</li> <li>简化性</li></ul> <p><strong>IO流</strong></p> <p>常用的输入输出流是</p> <p>字节流：FileOutputStream、FileInputStream</p> <p>字符流：FileWriter、FileReader</p> <p>字符流是基于字节流的封装是包装流，是专门用来处理文本数据的。字符流是在普通字节流的基础上，在内部<strong>封装</strong>了一个可以<strong>用来编解码的缓冲区</strong>(字符流=字节流+编码表)。</p> <table><thead><tr><th>类型</th> <th>字节输出流</th> <th>字节输入流</th> <th>字符输出流</th> <th>字符输入流</th></tr></thead> <tbody><tr><td>抽象基类</td> <td>OutputStream</td> <td>InputStream</td> <td>Writer</td> <td>Reader</td></tr> <tr><td>文件相关</td> <td><strong>FileOutputStream</strong></td> <td><strong>FileInputStream</strong></td> <td><strong>FileWriter</strong></td> <td><strong>FileReader</strong></td></tr> <tr><td>缓冲相关</td> <td>BufferedOutputStream</td> <td>BufferedInputStream</td> <td>BufferedWriter</td> <td>BufferedReader</td></tr> <tr><td>转换相关</td> <td></td> <td></td> <td><strong>OutputStreamWriter</strong></td> <td><strong>InputStreamReader</strong></td></tr> <tr><td>打印流</td> <td>PrintStream</td> <td></td> <td>PrintWriter</td> <td></td></tr> <tr><td>数据流</td> <td>DataOutputStream</td> <td>DataInputStream</td> <td></td> <td></td></tr> <tr><td>对象流</td> <td>ObjectOutputStream</td> <td>ObjectInputStream</td> <td></td> <td></td></tr></tbody></table> <p><strong>FileOutputStream</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">FileOutputSteam</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;a.txt&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;你好吗？&quot;</span><span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>write用法：
write(int b)
write(byte[] b)
write(byte[] b, int off, int len)</p> <p><strong>FileInputStream</strong></p> <p>方式一：按单字节读取</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">FileImputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;D:/1/1.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> readData<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>readData <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>readData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>方式二：按多字节读取</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">FileInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;D:/1/1.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> readCount<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>readCount <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> readCount<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>多线程</strong></p> <p><strong>创建线程的三种方式</strong></p> <ol><li><p>创建Thread类的子类对象</p></li> <li><p>基于Runnable接口创建Thread对象</p></li></ol> <p>​	使用Thread类的构造器Thread(Runnable target)创建线程。
​	有两种方式：
​		(1) 创建一个实现Runnable接口的类，创建子类对象，然后传递给Thread构造器，创建一个Thread对象。
​		(2) 匿名内部类和lambda表达式</p> <ol start="3"><li>基于Callable接口创建Thread对象</li></ol> <p>​		(1) 实现Callable接口
​		(2) 创建一个FutrueTask对象，以Callable实现类的对象作为参数传递给FutureTask的构造器。
​		(3) 将FutrueTask对象作为参数传递给Thread构造器，创建一个Thread对象。</p> <p>方式一和方式二的比较
(1) 方式一必须直接继承Thread类，而java是单继承的，方式二没有这种限制。
(2) 方式二把线程对象和任务分开定义，实现了解耦，多个线程可以做同一个任务，更有利于线程间的数据共享。</p> <p><strong>run() 和 start() 方法有什么区别</strong></p> <ol><li>run()方法
run()方法中定义了线程要执行的任务，直接调用run方法并不会启动一个新的线程，而只是普通的方法调用，在当前的线程中执行run()方法中的代码。</li> <li>start()方法
start()方法用于启动一个新的线程。当一个线程调用start()方法后，该线程会执行run()方法中的代码。</li></ol> <p><strong>线程池</strong></p> <p>线程容器：负责存储维护一组线程的容器，其中的线程可以被反复使用。
任务队列：是一个阻塞队列，用于存储线程池当前等待执行的任务。
**任务队列就像一个流水线，线程容器中的线程就像工人。**如果线程容器中还有空闲的线程，就从任务队列队首获取任务并执行，如果没有空闲的线程，任务队列就排队等待。任务比较多时，还可以创建更多的线程来执行任务。</p> <p>流程：
(1) 创建线程池（对象）
java.util.concurrent.Executors：工具类，用于生成线程池对象。
java.util.ocncurrent.ExecutorService：一个接口，全体线程池类型的父类，用于指代线程池对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//可自动扩容的线程容器</span>
<span class="token class-name">ExecutorService</span> pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//创建一个固定线程数量的线程池</span>
<span class="token class-name">ExecutorService</span> pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//线程数量固定为1</span>
<span class="token class-name">ExecutorService</span> pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>(2) 向线程池提交任务，先来先执行。
依赖于接口java.util.concurrent.ExecutorService当中的两个submit方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span>
</code></pre></div><p><strong>提交Runnable任务</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> demo <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyRunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>提交Callable任务</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> demo <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//submit方法的返回值类型是Future</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> callResult <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//通过Future接口的get()方法获取call方法返回值</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> callResult<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Sytem</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyCallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;你好！&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>(3) 任务调度执行。
(4) 线程池关闭。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//执行完任务列表中所有已提交的任务，关闭线程池，不在接收新的任务</span>
<span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//立刻停止所有正在执行的任务，也不再处理任务列表中等待的任务，并返回正在等待执行的任务列表</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>线程池任务执行流程</strong>：</p> <p>依次将他们&quot;填满&quot;</p> <table><thead><tr><th>corePoolSize</th> <th>workQueue</th> <th>maximumPoolSize</th></tr></thead> <tbody></tbody></table> <p>① 当线程池小于coreSize时</p> <p>② 当线程池达到coreSize时</p> <p>③ 当workQueue已满，且maxPoolSize &gt; corePoolSize时</p> <p>④ 当线程数大于maximumPoolSize时，新提交任务由RejectedExecutionHandler处理。</p> <p>⑤  当线程池中<strong>超过corePoolSize</strong>，<strong>空闲时间达到keepAliveTime</strong>，关闭空闲线程。</p> <p>⑥ 当设置了allowCoreThreadTimeOut(true)，空闲时间达到keepAliveTIme，关闭空闲线程。</p> <table><thead><tr><th>JUC提供的线程池创建方式</th> <th>corePoolSize</th> <th>maximumPoolSize</th> <th>keepAliveTime</th> <th>unit</th> <th>workQueue</th></tr></thead> <tbody><tr><td>newCachedThreadPool</td> <td>0</td> <td>integer.MAX_VALUE</td> <td>60L</td> <td>TimeUnit.SECONDS</td> <td>SynchronousQueue(同步队列)</td></tr> <tr><td>newFixedThreadPool</td> <td>接收的参数n</td> <td>接收的参数n</td> <td>0L(不限时)</td> <td>TimeUnit.MILLISECONDS</td> <td>LinkedBlockingQueue(误无界阻塞队列)</td></tr> <tr><td>newSingleThreadPool</td> <td>1</td> <td>1</td> <td>0L</td> <td>TimeUnit.MILLISECONDS</td> <td>LinkedBlockingQueue(误无界阻塞队列)</td></tr> <tr><td>newScheduledThreadPool</td> <td>传递来的参数</td> <td>Integer.MAX_VALUE</td> <td>0</td> <td>TimeUnit.MANOSECONDS</td> <td>DelayedWorkQueue(按超时时间升序排列的队列)</td></tr></tbody></table> <table><thead><tr><th>JUC提供的线程池创建方式</th> <th>使用场景</th></tr></thead> <tbody><tr><td>newCachedThreadPool</td> <td>执行很多短期异步的小程序或者负载较轻的服务器</td></tr> <tr><td>newFixedThreaPool</td> <td>执行长期的任务，性能好很多</td></tr> <tr><td>newSingleThreadPool</td> <td>一个任务一个任务执行的场景</td></tr> <tr><td>newScheduledThreadPool</td> <td>周期性执行任务的场景</td></tr></tbody></table> <p><strong>注解反射</strong></p> <p>注解就是Java代码中的一个特殊的标记，往往和反射搭配使用，</p> <p><strong>注解：</strong></p> <p>注解的注解(元注解)：</p> <table><thead><tr><th>元注解</th> <th></th></tr></thead> <tbody><tr><td>@Target(ElementType.METHOD)</td> <td><strong>用于指定该注解使用的位置</strong>。ElementType.TYPE：整个类。ElementType.FIELD：成员变量。ElementType.CONSTRUCTOR：构造器。ElementType.METHOD：成员方法。<strong>当没有@Target注解时，该注解可用于任何地方。</strong></td></tr> <tr><td>@Retention(RetentionPolicy.RUNTIME)</td> <td><strong>注解的存活范围</strong>。RetentionPolicy.RUNTIME：该注解会由JVM保留。RetentionPolicy.CLASS：该注解会在编译时由编译器保留。RetentionPolicy.SOURCE：该注解仅保留在.java源文件中，会被编译器忽视(类似于注释)。<strong>当没有@Retention注解时，默认值为RetentionPolicy.CLASS。</strong></td></tr></tbody></table> <table><thead><tr><th>注解的作用</th> <th></th></tr></thead> <tbody><tr><td>编译检查</td> <td>@Override，如果子类中有方法被@Override标示，但父类中没有同名方法，就会编译报错。</td></tr> <tr><td>在反射中使用</td> <td>在反射中可以获取一个类的类、方法、属性上的注解，动态代理</td></tr> <tr><td>根据注解生成代码</td> <td>lombok插件</td></tr> <tr><td>自定义注解</td> <td>AOP、切面类、自定义注解</td></tr></tbody></table> <p>自定义注解</p> <p>注解通过&quot;@注解名&quot;实例化。</p> <p>通过&quot;@注解名(属性1=属性值1，属性2=属性值2...)&quot;的形式给注解的属性赋值，数组类型的属性用&quot;{}&quot;赋值。</p> <p>注解的名为value的属性赋值可以不写属性名(当只给value赋值时才能不写属性名)。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@MyAnnotation</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@MyAnnotation</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">)</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@MyAnnotation</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">777</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token string">&quot;777&quot;</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;777&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>反射：</strong></p> <p>获取Class对象的方式</p> <ul><li>Object类的getClass方法</li> <li>类名/接口名.class</li> <li>Class.forName(&quot;全限定类名&quot;)</li></ul> <p>获取构造器、成员变量、方法</p> <p>类对象.getXXX()、类对象.getDeclaredXXX()</p> <p>其中XXX可以替换成Constructor、Field、Method，分别用来获取Constructor、Field、Method。不带Declared的方法只获取修饰符为public的Constructor、Field、Method，带Declared的方法可以获取所有的Constructor、Field、Method。</p> <p>上面的方法中没有参数就是获取所有的构造器/成员变量/方法</p> <table><thead><tr><th></th> <th>获取方法：类对象.getXXX()、类对象.getDeclaredXXX()</th> <th>使用</th></tr></thead> <tbody><tr><td>构造器Constructor</td> <td>获取带有形参的<strong>构造器</strong>，参数部分要写形参类型的类对象。</td> <td>xxxConstructor.newInstance()</td></tr> <tr><td>成员变量Field</td> <td>获取指定的的<strong>成员变量</strong>，参数部分直接写成员变量的字符串就行了。</td> <td>xxxField.set(该类对象，属性值)；xxxField.get(该类对象)；</td></tr> <tr><td>成员方法Method</td> <td>获取带有形参的<strong>方法</strong>，参数部分要写方法的名称和形参类型的类对象。</td> <td>xxxMethod.invoke(该类对象，实参列表)</td></tr></tbody></table> <p>成员变量和成员方法调用的参数中的对象都是通过反射创建的实例。</p> <p>暴力破解权限(当调用的构造器、属性、方法因为权限问题不可达，就可以使用这个方法破解权限问题)</p> <div class="language-java extra-class"><pre class="language-java"><code>declaredXXX<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>Stream流</strong></p> <p>Stream流式jdk1.8提供的对集合数据进行优化操作的一种数据处理方式。</p> <p>通常使用集合类对象.stream()的方式创建流。</p> <p>使用场景：</p> <table><thead><tr><th style="text-align:left;">创建流</th> <th style="text-align:left;">中间操作</th> <th style="text-align:left;">终止操作</th></tr></thead> <tbody><tr><td style="text-align:left;">集合类的Stream</td> <td style="text-align:left;">filter (过滤)</td> <td style="text-align:left;">count() (计数)</td></tr> <tr><td style="text-align:left;">由值创建</td> <td style="text-align:left;">distinct (去重)</td> <td style="text-align:left;">collect (存储为List)</td></tr> <tr><td style="text-align:left;">由数组创建</td> <td style="text-align:left;">limit (截取)</td> <td style="text-align:left;">anyMatch (是否有匹配的)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;">skip (跳过)</td> <td style="text-align:left;">allMatch (是否都匹配)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;">map (转换)</td> <td style="text-align:left;">noneMatch (是否没有匹配的)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;">sorted (排序)</td> <td style="text-align:left;">findAny (找到任意一个元素)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;"></td> <td style="text-align:left;">findFirst (找到第一个元素)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;"></td> <td style="text-align:left;">forEach (遍历流中的元素)</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;"></td> <td style="text-align:left;">reduce (按指定方式减少元素)</td></tr></tbody></table> <p>在collect()中可以使用Collectors.groupingBy(类名::get属性名)将流中的数据分组，处理结果为Map&lt;属性类型, List&lt;类名&gt;&gt;。其中&quot;类名::get属性名&quot;就是分类的依据。</p> <p><strong>Lambda表达式</strong></p> <blockquote><p>lambda表达式是Java8的一个新特性，可以取代接口的匿名内部类，写出更简洁的代码。</p></blockquote> <ol><li>语法和基本使用</li></ol> <p>形参列表：强制子类实现的抽象方法的形参列表
“{}”：重写抽象方法的方法体。</p> <div class="language- extra-class"><pre><code>能够用lambda表达式创建子类对象的接口必须是功能接口(FunctionalInterface)
&gt; 功能接口的概念：
&gt; 指的是接口中，有且仅有一个强制子类实现的抽象方法的接口。、

功能接口只有一个方法吗？只有一个抽象方法吗？
    (1) 功能接口中可以有默认方法和静态方法。
    (2) 如果一个抽象方法可以用Object类的某个方法作为默认实现，那么该抽象方法就不会强制子类实现。
</code></pre></div><ol start="2"><li><p>类型推断的方式
(1) 直接用父类接口引用接收
(2) 类似于强制类型转换
((接口的名字) lambda表达式)</p> <p>(3) 借助形参的数据类型（lambda表达式作为参数）
(4) 借助方法的返回值类型（lambda表达式作为返回值）</p></li> <li><p>简化
(1) &quot;(形参列表)&quot;中的形式参数数据类型可以省略。
(2) “{}” 如果重写的方法体只有一条语句，就可以省略，如果这一句是return语句，可以直接省略return。
(3) 方法引用
用一个已经实现的方法作为lambda表达式抽象方法的实现
I. 返回值类型
功能接口中的抽象方法的
返回值类型是void或基本数据类型，必须保持一致。
返回值类型是引用数据类型，可以保持一致和返回它的子类。
II.调用格式：不省略“-&gt;”
(形参列表) -&gt; 已实现方法的调用(形参列表);
III.调用格式：省略“-&gt;”
已实现方法的归属者:: 已实现的方法的方法名;
已实现方法的归属者：静态方法属于类，成员方法属于对象</p></li></ol> <h3 id="_2-集合类"><a href="#_2-集合类" class="header-anchor">#</a> 2. 集合类</h3> <p>List、Set、Map 等集合类，HashMap 的源码。</p> <p><a href="https://changjishun.github.io/blog/skills/DSDB/Collection.html" target="_blank" rel="noopener noreferrer">https://changjishun.github.io/blog/skills/DSDB/Collection.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://changjishun.github.io/blog/skills/DSDB/Map.html" target="_blank" rel="noopener noreferrer">https://changjishun.github.io/blog/skills/DSDB/Map.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>数组、栈、队列、二叉树、图、查找、排序、动态规划、回溯算法(举例排列组合、解二叉树)等常见的数据结构与算法。</p> <h3 id="_3-mysql、redis"><a href="#_3-mysql、redis" class="header-anchor">#</a> 3. MySQL、Redis</h3> <h4 id="数据库设计三大范式"><a href="#数据库设计三大范式" class="header-anchor">#</a> 数据库设计三大范式</h4> <h5 id="第一范式"><a href="#第一范式" class="header-anchor">#</a> 第一范式</h5> <p>每个字段的属性不可再分，比如一个字段包含联系方式又包含联系人，就违反了第一范式。</p> <h5 id="第二范式"><a href="#第二范式" class="header-anchor">#</a> 第二范式</h5> <p>一个主键能唯一确定一条记录</p> <h5 id="第三范式"><a href="#第三范式" class="header-anchor">#</a> 第三范式</h5> <p>消除传递依赖</p> <p>反例：</p> <p>比如有一个表有学号、姓名、系名、系主任名</p> <p>其中学号 -&gt; 系名、系名 -&gt; 系主任名，那么就可以推：学号 -&gt; 系主任名</p> <p>第三范式就是要消除这种情况，解决方法就是将该表拆分成学生表和系主任表两张表。</p> <p>A -&gt; B：A决定B，B依赖于A</p> <h4 id="mysql优化策略"><a href="#mysql优化策略" class="header-anchor">#</a> MySQL优化策略</h4> <p><strong>(1)慢查询</strong></p> <p>慢查询是指执行时间超过预设阈值的查询语句。优化慢查询是提高数据库性能的重要任务之一。</p> <p>在日常开发中，我们会给表加索引来提高MySQL的查询效率。但我们有时会遇到给字段加了索引，，但是没有走索引，索引失效的情况，进而导致MySQL产生慢查询。</p> <p><strong>慢查询产生的原因：</strong></p> <p><strong>①sql没有加索引</strong></p> <p><strong>②索引失效的情况</strong></p> <ul><li>联合查询不满足最左匹配原则。</li></ul> <blockquote><p>最左匹配原则：对于联合索引，一个索引由多个字段组成，索引的生效范围是从最左开始的，比如一个索引有(a, b, c)三个字段组成，用哪些作为查询条件才可以走这颗索引树呢，只有(a), (a, b), (a, b, c)。</p></blockquote> <ul><li>like查询以%开头。</li> <li>where条件的索引列有运算。</li> <li>索引列使用函数。</li> <li>查询条件中有or，但是or的字段不是所有都有索引。</li></ul> <p><strong>③深分页</strong></p> <p>MySQL需要扫描大量的数据才能找到指定页的数据，Page越大查询时间越久，会导致数据库性能急剧下降，并且占用大量的CPU、内存资源。</p> <p>深分页导致SQL变慢的原因：</p> <p>limit语句会先扫描offset+n行，然后再丢弃前offset行，返回后n行数据，也就是说limit 10 0000, 10就会扫描10 0010行，而limit 0， 10只扫描10行。</p> <p>深分页优化：</p> <p>标签记录法：</p> <p>就是标记上一次查询到了那一条了，下次再来查的时候，就从这条开始往下扫描。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> goods <span class="token keyword">limit</span> <span class="token number">10</span> <span class="token number">0010</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> goods <span class="token keyword">where</span> id <span class="token operator">&gt;</span> 
</code></pre></div><p><strong>(2)优化查询：</strong></p> <p><strong>尽量避免使用 select * ，返回无用的字段会降低效率。</strong></p> <p>优化方式：只能使用具体的字段代替 select 具体字段，只返回使用到的字段。</p> <p><strong>尽量避免使用 in 和 not in，会导致数据库引擎放弃索引进行全表扫描。</strong></p> <p>优化方式：如果是连续数值，可以用 between 代替，如果是子查询，可以用 exists代替。</p> <p><strong>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</strong></p> <p>优化方式:尽量在字段后面使用模糊查询。</p> <p><strong>尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描。</strong></p> <p>优化方式:可以给字段添加默认值 0，对 0 值进行判断。</p> <p><strong>读写分离：</strong></p> <ul><li><p>读写分离是主服务器负责写，从服务器负责读。读写分离可以大幅度的提高读性能，小幅度的提高写性能。</p></li> <li><p>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</p></li> <li><p>业务数据库将写请求发给数据库主机，将写请求发送给从机。，</p></li></ul> <p><strong>读写分离优点</strong></p> <p>① 减轻数据库的IO压力，由多个数据分担用户的查询请求压力，大多数公司的业务场景都是读多写少。</p> <p>② 减少因为数据库读写而导致的加锁逻辑，影响数据库的读写性能。</p> <p><strong>分库分表：</strong></p> <p>当MySQL数据量达到<strong>500W条数据</strong>后，由于查询的数据过多，即便进行了很多优化，还是不可避免的出现<strong>操作性能下降</strong>，这时就要考虑对其进行切分，减缓数据库的压力，减少查询时间。</p> <table><thead><tr><th></th> <th>描述</th></tr></thead> <tbody><tr><td>垂直分库</td> <td>按功能模块拆分，比如分为用户库、商品库、订单库</td></tr> <tr><td>垂直分表</td> <td>当一张表有太多的字段后，需要按照业务模块进行拆分，如用户表拆分为用户基础信息表、用户登录信息表、用户地址表等。</td></tr> <tr><td>水平切分</td> <td><strong>将一个表的数据分为多个表进行存储</strong>，比如将用户表拆分为用户表1、用户表2、用户表3...水平分割分为<strong>库内分表</strong>和<strong>分库分表</strong>。<strong>库内分表</strong>就是将拆分后的表格存储在同一个数据库中，<strong>分库分表</strong>就是将拆分后的表格存储在不同的数据库中，这样就就可以避免存储在同一个服务器中仍然会使用同一台机器的CPU、IO。</td></tr></tbody></table> <p><strong>数据库集群</strong></p> <h4 id="多表查询"><a href="#多表查询" class="header-anchor">#</a> 多表查询</h4> <p><strong>连接查询</strong></p> <p><strong>交叉连接</strong></p> <p>交叉连接其实就是在求多个表之间的笛卡尔积，就是两表之间每一行两两组合。</p> <p>例如左表有3条记录，右表有4条记录，他们两两组合就有12种结果。</p> <p>交叉查询本身没有意义，但是内连接和外连接都是基于交叉查询的结果去筛选的。</p> <p><strong>内连接</strong></p> <p>将两个之间的记录按连接条件匹配，满足连接条件的两行就会拼接成新的一行。</p> <p>只会返回匹配到的</p> <p><strong>外连接</strong></p> <p>与内连接不同的是外连接会保留左表或右表中没有匹配上的行，这些行对应的剩下来的属性都赋值null</p> <p>左外连接就是保留左表中没有匹配上的行，右外连接就是保留右表中没有匹配上的行。</p> <h4 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h4> <p><a href="https://changjishun.github.io/blog/skills/DSDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html#%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener noreferrer">https://changjishun.github.io/blog/skills/DSDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html#%E7%B4%A2%E5%BC%95<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h4> <p><a href="https://changjishun.github.io/blog/skills/DSDB/JDBC.html#%E4%BB%8B%E7%BB%8D-2" target="_blank" rel="noopener noreferrer">https://changjishun.github.io/blog/skills/DSDB/JDBC.html#%E4%BB%8B%E7%BB%8D-2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <table><thead><tr><th></th> <th style="text-align:center;">脏读</th> <th style="text-align:center;">不可重复读</th> <th style="text-align:center;">虚读/幻读</th></tr></thead> <tbody><tr><td>读未提交</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr> <tr><td>读已提交</td> <td style="text-align:center;">√</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr> <tr><td>可重复读</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td> <td style="text-align:center;">×</td></tr> <tr><td>串行化</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td></tr></tbody></table> <h4 id="redis常见数据结构和使用场景"><a href="#redis常见数据结构和使用场景" class="header-anchor">#</a> Redis常见数据结构和使用场景</h4> <p>Redis是一个NoSQL数据库。</p> <p>NoSQL: not only SQL。表示非关系型数据库（不支持SQL标准语法）。</p> <p>Redis是一个使用C语言编写的、免费的、开源的、支持网络、可基于内存、亦可持久化的日志型，key-value 非关系型数据库，并且提供多种语言的API</p> <ul><li><p>C语言编写的</p></li> <li><p>开源的（<a href="https://github.com/redis" target="_blank" rel="noopener noreferrer">https://github.com/redis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p></li> <li><p>可基于内存：是把数据存在到内存上的</p></li> <li><p>可持久化：可以把内存里面的数据持久化到磁盘(为了实现数据恢复)</p></li> <li><p>key-value：数据在内存中是以键值对的方式来存储的</p></li> <li><p>支持网络：客户端是通过网络连接服务端的</p></li> <li><p>支持多种语言：可以在各种语言的代码中操作Redis</p></li></ul> <p>常见数据结构及使用场景</p> <table><thead><tr><th>数据结构</th> <th>使用场景</th></tr></thead> <tbody><tr><td>string</td> <td>setnx</td></tr> <tr><td>list</td> <td>本项目为了解决超卖问题，使用list存储商品库存</td></tr> <tr><td>set</td> <td>求共同好友，好友推荐</td></tr> <tr><td>hash</td> <td>类似于Java中的Map，可以用于存储购物车中的商品信息</td></tr> <tr><td>sortedSet</td> <td>计算商品的热度排名，让商品信息按热度排序</td></tr></tbody></table> <p>缓存问题分析</p> <ul><li><p><strong>缓存穿透</strong>：查询的数据在数据库中不存在（<strong>访问数据库中不存在的数据</strong>）。这样会导致这个不存在的数据每次请求都要到数据库中查询。如果查询这种不存在的数据的请求量很大就很容易导致数据库宕机。</p> <p>解决办法：针对这种数据库中查询不到的数据，就将查询结果定义为null或默认值缓存到redis中，并将缓存结果定义一个过期时间。</p></li> <li><p><strong>缓存雪崩</strong>：指redis中具有过期时间的数据在<strong>同一时刻失效</strong>，就会导致大量的请求同时访问数据库，导致数据库瞬时压力过大甚至宕机。</p> <p>解决方法：给具有过期时间的数据设置随机的过期时间，这样每一个缓存数据的过期时间相同的概率就会降低，就很难会引起集体失效的事件。</p></li> <li><p><strong>缓存击穿</strong>：指当缓存中某个key过期了，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。这样就会导致数据库压力瞬时剧增，造成大量请求阻塞，甚至直接挂掉。</p> <p>解决方法：使用Redis提供的分布式锁，保证同一时刻只能有一个查询请求加载热点数据到缓存中，这样，其他的线程只需要等待该线程运行完毕，即可重新从redis中获取数据。</p></li></ul> <h4 id="redis的持久化策略"><a href="#redis的持久化策略" class="header-anchor">#</a> Redis的持久化策略</h4> <p><strong>RDB(Redis DateBase)</strong>：通过内存快照的形式来讲内存中的数据持久化到磁盘中，是Redis默认的持久化策略，没有提供开关关闭。</p> <p>快照：是一种内存技术，可以像对内存拍照一样，保存内存当时的状态。</p> <ul><li>快照的速度很快</li> <li>快照保存的是一种<strong>数据的状态</strong>，占用磁盘空间很小</li> <li>快照会<strong>保存完整的数据</strong></li></ul> <p><strong>AOF(Append Only File)</strong>：通过追加日志文件的方式来保存数据，将用户的每一个写入命令保存到文件中，后续可以通过执行这个文件的所有命令来恢复数据</p> <table><thead><tr><th>RDB</th> <th>AOF</th></tr></thead> <tbody><tr><td>每次保存的是触发RDB时刻的完整数据</td> <td>可以做到不丢失数据</td></tr> <tr><td>可能会丢失上一次持久化之后所有写入的数据</td> <td>保存数据生成的文件会越来越大，占用磁盘空间比较大</td></tr> <tr><td>保存、还原数据很快</td> <td>还原数据是通过执行文件中所有的命令来还原的，还原速度比较慢</td></tr></tbody></table> <p>RDB和AOF可以同时运行，当两种机制都开启的时候，恢复数据的时候优先从AOF生成的文件来恢复。</p> <h4 id="redis的内存淘汰策略"><a href="#redis的内存淘汰策略" class="header-anchor">#</a> Redis的内存淘汰策略</h4> <p>当Redis内存满了之后会触发内存淘汰策略</p> <p>总体有两类，每一类共有的：lru、lfu、random</p> <p>针对设置了过期时间的数据集</p> <table><thead><tr><th>策略</th> <th>淘汰对象</th></tr></thead> <tbody><tr><td>volatile-<strong>lru</strong>(least-recent-used)</td> <td>最近最少使用数据</td></tr> <tr><td>volatile-<strong>lfu</strong></td> <td>选择一段时间内使用最少的数据</td></tr> <tr><td>volatile-<strong>random</strong></td> <td>随机选择数据</td></tr> <tr><td>volatile-ttl</td> <td>最近将要过期的数据</td></tr></tbody></table> <p>针对所有数据集</p> <table><thead><tr><th>策略</th> <th>描述</th></tr></thead> <tbody><tr><td>allkeys-<strong>lru</strong></td> <td>最近最少使用的数据</td></tr> <tr><td>allkeys-<strong>random</strong></td> <td>随机选择数据</td></tr> <tr><td>allkeys-<strong>lfu</strong></td> <td>选择一段时间内使用最好的数据</td></tr> <tr><td>no-evication</td> <td>禁止淘汰策略</td></tr></tbody></table> <p>选择哪一种策略比较合理？</p> <p>从效率角度出发：allkeys-random</p> <p>从合理性角度出发：volatile-lru</p> <h3 id="_4-spring"><a href="#_4-spring" class="header-anchor">#</a> 4. Spring</h3> <h4 id="ioc"><a href="#ioc" class="header-anchor">#</a> IOC</h4> <p>使用 Spring 管理对象，实现依赖注入，实现了<strong>解耦</strong>，避免了一处改动就要修改多处代码，减少了多次创建对象造成的资源浪费。</p> <p>为什么要将对象的创建权利交给IOC容器？</p> <p>① 解耦</p> <p>举例：比如有10个Controller依赖了UserService，最开始实例化的是UserServiceImpl</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>后面需要换一个实现类UserServiceImpl2</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那就需要逐个修改那几个Controller</p> <p>使用IOC管理对象后，只需要修改实现类就行了，无需修改使用到该实现类的代码。</p> <p>② 复用对象</p> <p>在JavaEE中，每使用某个类的对象一次就实例化一次，会造成资源的浪费，而spring的IOC思想就是将一个类的对象存入IOC容器中，等到需要使用的时候，就从容器中取即可，这样由spring管理的类(组件)，都只有唯一的对象。</p> <h4 id="aop-aspectj"><a href="#aop-aspectj" class="header-anchor">#</a> AOP（aspectj）</h4> <p>AOP(Aspect Oriented Programming)：面向切面编程</p> <p>背后的思想是动态代理，代理可以在原有的核心业务的基础上添加额外的功能，这样就可以将比较常用的非核心业务提取出来，由代理类替我们完成</p> <p>面向切面编程：定义一个切面类，切面里面定义了切入点(需要使用代理的地方)和通知方法(代理增加的额外的方法)，在我们使用切入点范围内的类的对象时，Spring会在指定的位置自动添加上额外的方法。</p> <p>切入点：是定位连接点的方式，是用于确定需要增强的范围</p> <p>连接点：可以使用通知的地方。</p> <p>增强：执行额外的方法。</p> <p>切面：用于定义增强方法。</p> <p>写通知方法，在方法上写下列注解，不同的注解决定通知方法相对委托类方法执行的位置</p> <table><thead><tr><th>注解</th> <th>解释</th></tr></thead> <tbody><tr><td>@Before</td> <td>在委托类方法之前执行</td></tr> <tr><td>@AfterReturning</td> <td>在委托类有返回值之后执行</td></tr> <tr><td>@AfterThrowing</td> <td>在委托类抛异常后执行</td></tr> <tr><td>@After</td> <td>在委托类方法之后执行</td></tr> <tr><td>@Around</td> <td>环绕，委托类在该方法中执行</td></tr></tbody></table> <h4 id="springbean的生命周期"><a href="#springbean的生命周期" class="header-anchor">#</a> SpringBean的生命周期</h4> <p><strong>初始化阶段的方法</strong></p> <ol><li>Bean的实例化</li> <li>设置参数方法</li> <li>BeanNameAware、BeanFactoryAware、ApplicationContextAware</li> <li>BeanPostProcessor的postProcessBeforeInitialization</li> <li>InitializingBean的afterPropertiesSet方法</li> <li>自定义的init方法</li> <li>BeanPostProcessor的postProcessAfterInitialization</li></ol> <div class="language-java extra-class"><pre class="language-java"><code>	<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AdminService</span><span class="token punctuation">,</span>
        <span class="token class-name">BeanNameAware</span><span class="token punctuation">,</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">,</span>
        <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span>
    	<span class="token class-name">DisposableBean</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>

	<span class="token comment">/**
     * 1. 构造器，可以使用有参构造器，也可以使用无参构造器
     */</span>

	<span class="token comment">/**
     * 2. 设置属性值
     *    a. 构造方法注入
     *    b. 方法注入
     *    c. 成员变量注入
     *
     * 常量也可以设置属性值：@Value → 后面SpringBoot阶段会去使用
     */</span>
     
     <span class="token comment">/**
     * 3. BeanNameAware、BeanFactoryAware、ApplicationContextAware
     *   a. BeanNameAware → setBeanName → 传入beanName：当前组件的id
     *   b. BeanFactoryAware → setBeanFactory → 传入beanFactory：当前组件所在的容器
     *   c. ApplicationContextAware → setApplicationContext → 传入applicationContext：当前组件所在的容器
     *
     *   在这里传入这些值：目的是为了让当前组件能够获取到这些值，因为你接下来的一些方法里有可能使用到这样的一些值
     *   如果你需要获得这些值，就实现接口；如果不需要，则不实现接口；这不是必须的
     */</span>
     
     <span class="token comment">/**
     * 5. InitializingBean的afterPropertiesSet方法
     * 实现InitializingBean接口，重写afterPropertiesSet方法
     * 5和6都是初始化方法，只不过5通常是第三方依赖提供的初始化方法，6通常是我们自己开发的时候提供的初始化方法
     */</span>
     
     <span class="token comment">/**
     * 6. 自定义的init方法
     * 通过@PostConstruct注解指定方法
     */</span>
     
     <span class="token comment">/**
     * 销毁方法
     *   自定义销毁方法 @PreDestroy注解指定方法
     *   DisposableBean接口的destroy
     *
     */</span>
</code></pre></div><p><strong>容器关闭阶段的方法</strong></p> <p>单例的组件才会执行到对应的方法</p> <p>DisposableBean的destroy方法</p> <p>自定义的destroy方法</p> <p><strong>简化版</strong></p> <ol><li><p>实例化：</p> <p>当Spring容器加载配置文件时，会根据配置创建Bean的定义。然后，通过调用Bean的构造函数来实例化Bean对象。</p></li> <li><p>属性赋值：</p> <p>在实例化Bean后，Spring容器将通过依赖注入（Dependency Injection）或属性注入的方式来设置Bean的属性和依赖。这可以通过构造函数注入、Setter方法注入或注解方式实现。</p></li> <li><p>初始化：</p> <p>在属性赋值完成后，Spring容器会调用Bean的初始化回调方法。Bean的初始化可以通过实现InitializingBean接口的afterPropertiesSet()方法或在配置文件中指定init-method来完成。开发者可以在初始化回调方法中执行一些自定义的初始化逻辑。</p></li> <li><p>使用：</p> <p>在Bean完成初始化后，可以被应用程序使用。可以通过Spring容器获取Bean实例，并调用Bean的方法来执行相应的业务逻辑。</p></li> <li><p>销毁：</p> <p>当应用程序关闭或销毁时，Spring容器会调用Bean的销毁回调方法。Bean的销毁可以通过实现DisposableBean接口的destroy()方法或在配置文件中指定destroy-method来完成。开发者可以在销毁回调方法中执行一些清理资源的操作。</p></li></ol> <h4 id="spring事务"><a href="#spring事务" class="header-anchor">#</a> Spring事务</h4> <p><strong>事务的特性</strong></p> <ul><li>原子性 Atomicity</li> <li>一致性 Consistency</li> <li>隔离性 Isolation</li> <li>持久性 Durability</li></ul> <p><strong>事务并发引起的问题</strong></p> <ul><li>脏读
<ul><li>一个事务读取到另外一个事务<font color="red">还未提交</font>的数据</li></ul></li> <li>不可重复读
<ul><li>一个事务读取到另外一个事务<font color="red">已经提交</font>的数据<font color="red">（修改）</font></li></ul></li> <li>虚读/幻读
<ul><li>一个事务读取到另外一个事务<font color="red">已经提交</font>的数据<font color="red">（增删）</font></li></ul></li></ul> <p><strong>数据库的隔离级别</strong></p> <ul><li>读未提交（Read uncommitted）</li> <li>读已提交（Read committed）</li> <li>可重复读（Repeatable read）</li> <li>串行化（Serializable）</li></ul> <table><thead><tr><th></th> <th style="text-align:center;">脏读</th> <th style="text-align:center;">不可重复读</th> <th style="text-align:center;">虚读/幻读</th></tr></thead> <tbody><tr><td>读未提交</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr> <tr><td>读已提交</td> <td style="text-align:center;">√</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr> <tr><td>可重复读</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td> <td style="text-align:center;">×</td></tr> <tr><td>串行化</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td></tr></tbody></table> <p>MySql的默认隔离级别是可重复读，但没有虚读问题的。</p> <p><strong>事物的传播行为</strong></p> <p>以<strong>外围事务A，内部事务B</strong>举例</p> <p>当发生异常时</p> <table><thead><tr><th>事物的传播行为</th> <th></th></tr></thead> <tbody><tr><td>required</td> <td>一荣俱荣，不管谁发生异常都回滚</td></tr> <tr><td>requires_new</td> <td>外部不会影响内部，内部会影响外部</td></tr> <tr><td>nested</td> <td>外部会影响内部，内部不会影响外部</td></tr></tbody></table> <p><strong>事务注解@Transactional的使用</strong></p> <p>① 打开事物的注解驱动，在配置类上写@EnableTransactionManagement</p> <p>② 可以在类或方法上写上@Trasactional注解，注解可以指定事物的传播行为。</p> <h4 id="spring常用注解"><a href="#spring常用注解" class="header-anchor">#</a> Spring常用注解</h4> <p>注册组件的注解</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Component</td> <td></td></tr> <tr><td>@Controller</td> <td></td></tr> <tr><td>@Service</td> <td></td></tr> <tr><td>@Repository</td> <td></td></tr></tbody></table> <p>注入Bean的注解</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Autowired</td> <td></td></tr> <tr><td>@Inject</td> <td></td></tr> <tr><td>@Resource</td> <td></td></tr></tbody></table> <p>配置类相关注解</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Configuration</td> <td></td></tr> <tr><td>@ComponentScan</td> <td></td></tr></tbody></table> <p>切面相关注解</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Aspect</td> <td>用于声明一个切面类</td></tr> <tr><td>@PointCut</td> <td>用于指定切面中的通知方法作用的切入点</td></tr></tbody></table> <p>注入配置文件</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Value</td> <td>举例：@Value(&quot;${book.name}&quot;)</td></tr></tbody></table> <p>定时任务</p> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@EnableScheduling</td> <td>写在配置类上，开启定时任务开关</td></tr> <tr><td>@Scheduled</td> <td>用于声明定时任务，设置定时任务</td></tr></tbody></table> <h3 id="_5-springmvc"><a href="#_5-springmvc" class="header-anchor">#</a> 5. SpringMVC</h3> <h4 id="路径映射"><a href="#路径映射" class="header-anchor">#</a> 路径映射</h4> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@RequestMapping</td> <td>method属性可以指定请求方式，例如：@RequestMapping(method=RquestMethod.GET)</td></tr> <tr><td>@GetMapping</td> <td>等价于@RequestMapping(method=RquestMethod.GET)</td></tr> <tr><td>@PostMapping</td> <td>等价于@RequestMapping(method=RquestMethod.POST)</td></tr> <tr><td>@DeleteMapping</td> <td>等价于@RequestMapping(method=RquestMethod.DELETE)</td></tr> <tr><td>@PutMapping</td> <td>等价于@RequestMapping(method=RquestMethod.PUT)</td></tr></tbody></table> <h4 id="请求窄化"><a href="#请求窄化" class="header-anchor">#</a> 请求窄化</h4> <p>请求路径映射的注解可以写在类上面，也可以写在方法上面。</p> <p>窄化请求就是把一些前缀相同的URL的公共前缀提取出来放在类上面的@Request注解里，在具体的处理方法上面的路径映射注解就可以省略这些前缀。</p> <p>举例：</p> <p>如果有一个Controller专门处理请求以&quot;/api/user/inner&quot;开头的URL，就可以在该Controller的类上面直接写注解@RequestMapping(&quot;/api/user/inner&quot;)，然后针对每一个具体请求的处理方法写的注解为对应的URL中&quot;/api/user/inner&quot;后面的部分。</p> <h4 id="请求参数的封装"><a href="#请求参数的封装" class="header-anchor">#</a> 请求参数的封装</h4> <p>使用 SpringMVC 简化了对请求的处理，能够自动的获取 QueryString、PathVariable 和请求体中携带的数据并转化成指定的数据类型对象，能够将返回的对象自动转换成 JSON 数据返回给前端。</p> <p>这些注解都是写在方法的形参前，用于获取形参的值，注解的value(注解括号里的字符串)都是要获取的参数在请求报文中的名字或占位符</p> <table><thead><tr><th>注解</th> <th>解释</th></tr></thead> <tbody><tr><td>@PathVariable</td> <td>将url中的指定的参数赋给形参，使用占位符指定</td></tr> <tr><td>@RequestParam</td> <td>获取指定的请求参数</td></tr> <tr><td>@RequestHeader</td> <td>获取指定的请求头的值</td></tr> <tr><td>@CookieValue</td> <td>获取指定Cookie的值</td></tr> <tr><td>@SessionAttribute</td> <td>获取指定Session的值</td></tr></tbody></table> <p>@RequestBody注解用于接收json请求数据</p> <h4 id="自定义类型转换器"><a href="#自定义类型转换器" class="header-anchor">#</a> 自定义类型转换器</h4> <p>Spring MVC提供了类型转换器来将<strong>请求参数</strong>转换为<strong>方法参数</strong>所需的类型。如果需要自定义类型转换逻辑，可以实现<code>Converter</code>或<code>Formatter</code>接口，并通过配置将其注册到Spring MVC中。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCustomConverter</span> <span class="token keyword">implements</span> <span class="token class-name">Converter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyCustomType</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">MyCustomType</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 自定义类型转换逻辑，将字符串转换为自定义类型MyCustomType</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">return</span> convertedValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以实现<code>Converter</code>接口来创建自定义类型转换器。在上述示例中，将字符串转换为自定义类型<code>MyCustomType</code>。</p> <p>然后，在配置类或XML配置中注册自定义类型转换器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFormatters</span><span class="token punctuation">(</span><span class="token class-name">FormatterRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        registry<span class="token punctuation">.</span><span class="token function">addConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCustomConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="自定义拦截器"><a href="#自定义拦截器" class="header-anchor">#</a> 自定义拦截器</h4> <p>通过实现<code>HandlerInterceptor</code>接口，可以自定义拦截器来对请求进行<strong>预处理</strong>、<strong>后处理</strong>和<strong>完成处理</strong>。拦截器可以用于添加日志、权限验证、跨域处理等功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCustomInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在请求处理之前执行的逻辑，可以进行权限验证、日志记录等操作</span>
        <span class="token comment">// 返回true继续处理请求，返回false中止请求处理</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">ModelAndView</span> modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在请求处理之后、视图渲染之前执行的逻辑</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在请求完成后执行的逻辑，包括视图渲染之后</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以实现<code>HandlerInterceptor</code>接口来创建自定义拦截器，并根据需要实现相应的方法。在上述示例中，展示了在请求处理前、请求处理后和请求完成后执行的逻辑。</p> <p>然后，在配置类或XML配置中注册自定义拦截器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCustomInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述示例中，将自定义拦截器注册到拦截器注册表中，并使用<code>addPathPatterns</code>方法指定需要拦截的路径模式。</p> <h4 id="自定义异常处理器"><a href="#自定义异常处理器" class="header-anchor">#</a> 自定义异常处理器</h4> <p>Spring MVC允许开发者自定义异常处理器来处理控制器方法抛出的异常。通过实现<code>HandlerExceptionResolver</code>接口，可以定义全局异常处理逻辑，例如将异常信息转换为特定格式的响应。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//@ResponseBody</span>
<span class="token comment">//@ControllerAdvice</span>
<span class="token annotation punctuation">@RestControllerAdvice</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionControllerAdvice</span> <span class="token punctuation">{</span>

    <span class="token comment">// 我们要响应JSON</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">BaseRespVo</span> <span class="token function">handleArithmeticException</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">BaseRespVo</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;应用程序正在升级维护&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">MySQLSyntaxErrorException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">BaseRespVo</span> <span class="token function">handleMySQLSyntaxErrorException</span><span class="token punctuation">(</span><span class="token class-name">MySQLSyntaxErrorException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">BaseRespVo</span><span class="token punctuation">.</span><span class="token function">mysqlSyntaxError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="dispatcherservlet"><a href="#dispatcherservlet" class="header-anchor">#</a> DispatcherServlet</h4> <p>DispatcherServlet接收所有的请求，然后转发给对应的Controller处理。</p> <p>请求接收和转发：DispatcherServlet通过监听Web容器的请求，并拦截所有的请求。他根据配置的URL映射规则，将请求分发给相应的Controller进行处理。</p> <p>处理器映射：DispatcherServlet维护一个处理器映射表，用于将URL映射到具体的处理器(Controller)。处理器映射可以通过@RequestMapping注解或其他方式进行配置。</p> <h4 id="springmvc常见注解"><a href="#springmvc常见注解" class="header-anchor">#</a> SpringMVC常见注解</h4> <table><thead><tr><th>注解</th> <th></th></tr></thead> <tbody><tr><td>@Controller</td> <td></td></tr> <tr><td>@RestController</td> <td></td></tr> <tr><td>@ResponseBody</td> <td></td></tr></tbody></table> <p>其他常见的注解都在路径映射和参数封装中提到过。</p> <h3 id="_6-mybatis、mybatis-plus"><a href="#_6-mybatis、mybatis-plus" class="header-anchor">#</a> 6. MyBatis、MyBatis-Plus</h3> <h4 id="输入输出映射"><a href="#输入输出映射" class="header-anchor">#</a> 输入输出映射</h4> <p><strong>输入映射</strong></p> <table><thead><tr><th>传值</th> <th>取值</th></tr></thead> <tbody><tr><td>形参名</td> <td>#{形参名}</td></tr> <tr><td>@Param(&quot;注解值&quot;)</td> <td>#{注解值}</td></tr> <tr><td>对象</td> <td>#{成员变量名}</td></tr> <tr><td>使用@Param的对象</td> <td>#{注解值.成员变量名}</td></tr> <tr><td>Map</td> <td>#{key}</td></tr> <tr><td>使用注解的Map</td> <td>#{注解值.key}</td></tr> <tr><td>按形参位置传值</td> <td>使用#{arg0}、#{arg1}、#{arg2}...或#{param1}、#{param2}、#{param3}</td></tr></tbody></table> <p><strong>输出映射</strong></p> <p>一条结果：使用</p> <p>多条结果：使用List或Set接收</p> <p>ResultType: 写全类名或别名</p> <p>ResultMap: 用于把数据库中的字段与java实体类中的变量进行映射，指定将数据库中的哪个字段传给java中的哪个变量。</p> <p>column是数据库中的字段名，property是Java中的变量名</p> <h4 id="多表查询-2"><a href="#多表查询-2" class="header-anchor">#</a> 多表查询</h4> <p>Asociation: 用于一对一查询</p> <p>Collection: 用于一对多查询</p> <h4 id="动态sql"><a href="#动态sql" class="header-anchor">#</a> 动态SQL</h4> <table><thead><tr><th>标签</th> <th>描述</th> <th>使用场景</th></tr></thead> <tbody><tr><td><code>&lt;where&gt;</code></td> <td>帮助我们在最终执行的SQL语句中自动生成where关键字</td> <td>where标签内部一般搭配其他标签使用</td></tr> <tr><td><code>&lt;if&gt;</code></td> <td>根据接口方法传入的形参是否满足某个条件来决定是否拼接该标签中的内容</td> <td>对一个对象的各个属性进行筛选，例如该属性不为null，就拼接对应的查询条件，将该属性作为查询条件。</td></tr> <tr><td><code>&lt;choose&gt; &lt;when&gt; &lt;otherwise&gt;&lt;/choose&gt;</code></td> <td><code>&lt;when&gt;</code>相当于if、else if，<code>&lt;otherwise&gt;</code>相当于else</td> <td></td></tr> <tr><td>sql-include</td> <td>用于抽取公共的sql语句，使用<code>&lt;sql id=&quot;sql_name&quot;/&gt;</code>抽取，使用<code>&lt;include refid=&quot;sql_name&quot;/&gt;</code>引用</td> <td></td></tr> <tr><td>trim</td> <td>增加或删除指定的前、后缀。增加前后缀：prefix、suffix。删除前后缀：prefixOverrides、suffixOverrides</td> <td></td></tr> <tr><td>set</td> <td>去除set标签中的最后一个&quot;,&quot;，拼接set关键字</td> <td></td></tr> <tr><td>foreach</td> <td>collection传入参数的类型，如List就写list；item写循环中的元素名；separator写每一个循环的内容之间用什么分割</td> <td>可用于循环插入</td></tr></tbody></table> <p>使用<code>&lt;insert id=&quot;XXX&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;pone.id&quot;&gt;</code>将插入数据库后自动生成的id赋值给插入的对象的指定属性。</p> <h4 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h4> <p>懒加载也叫延时加载，就是在使用的时候才加载。在Mybatis进行分次查询的时候，假如第二次查询的内容没有被使用到的话，那么就不去执行第二次查询的SQL语句，等到用到第二次查询的内容的时候再去执行第二条SQL语句。</p> <ul><li><p>全局开关：在MyBatis的主配置文件里面的setting里面</p> <p><code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</code></p></li> <li><p>局部开关：用于指定关联属性的加载方式</p> <p>例如：在<code>&lt;collection&gt;</code>中指定fetchType=&quot;lazy&quot;</p></li></ul> <h4 id="两级缓存"><a href="#两级缓存" class="header-anchor">#</a> 两级缓存</h4> <p>MyBatis缓存指在Mybatis中单独开辟一块内存空间(Map)，用来存储查询到的数据。后续如果再次调用到了同样的查询，那么就会直接查询缓存。</p> <p>MyBatis默认开启了一级缓存，并且没有提供开关给用户关闭。</p> <table><thead><tr><th>缓存</th> <th></th></tr></thead> <tbody><tr><td>一级缓存</td> <td>同一个SqlSession获取的Mapper会走缓存</td></tr> <tr><td>二级缓存</td> <td>同一个namespace(Mapper.xml)共用一块内存</td></tr></tbody></table> <p>二级缓存开关：</p> <p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p> <p>二级缓存的优势：</p> <p>二级缓存是对一级缓存的优化，一级缓存的作用域只限于一个sqlSession连接，当连接关闭后，缓存就没用了，时效性太差了，而采用二级缓存后，缓存能在多个连接之间共享，缓存的利用率、命中率就大大提高。</p> <h4 id="mybatis-plus提供的接口常见的方法"><a href="#mybatis-plus提供的接口常见的方法" class="header-anchor">#</a> MyBatis-Plus提供的接口常见的方法</h4> <h4 id="条件构造器"><a href="#条件构造器" class="header-anchor">#</a> 条件构造器</h4> <p>用于构造where条件</p> <table><thead><tr><th>QueryWrapper</th> <th>UpdateWrapper</th></tr></thead> <tbody><tr><td>eq</td> <td>set</td></tr> <tr><td>like</td> <td></td></tr> <tr><td>between</td> <td></td></tr> <tr><td>isNotNull</td> <td></td></tr> <tr><td>orderByDesc</td> <td></td></tr> <tr><td>gt</td> <td></td></tr> <tr><td>ge</td> <td></td></tr> <tr><td>lt</td> <td></td></tr> <tr><td>le</td> <td></td></tr> <tr><td>or</td> <td></td></tr></tbody></table> <p>QueryWrapper和UpdateWrapper带不带Lambda的区别：体现在传递的参数中对数据库字段的表示方式不同</p> <p>前面带Lambda的，使用&quot;类名::get属性名()&quot;表示，不带Lambda的直接用字符串表示。</p> <p>用字符串表示字段可能会存在写的字段名和数据库不一致导致无法找到对应的字段，而使用lambda表达式就可以找到该数据库表对应的类中对应的属性，该类有注解表示其对应的数据库表，该方法有注解表示其对应的字段名。</p> <p><strong>常用注解</strong></p> <table><thead><tr><th>注解</th> <th>描述</th> <th>备注</th></tr></thead> <tbody><tr><td>@TableName</td> <td>定义数据库表和实体类的关系，写在<strong>实体类</strong>上面，用于指明该类对应的数据库表名</td> <td></td></tr> <tr><td>@TableId</td> <td>写在<strong>主键属性</strong>上，用于指定实体类中哪个成员变量（属性）对应数据库表中的主键</td> <td>该注解的type属性用于指定Mybatis-plus对主键设置的模式，例如：AUTO(数据库ID自增)、ASSIGN_ID(由Mybatis-Plus替我们生成id)</td></tr> <tr><td>@TableField</td> <td>写在<strong>普通属性</strong>上，用于指定普通属性和数据库字段之间的映射关系</td> <td>该注解属性exist设为false，就不会让该属性与数据库之间进行映射</td></tr> <tr><td>@TableLogic</td> <td>写在<strong>普通属性</strong>上，对数据库中的记录实现逻辑删除，比如有一个字段is_deleted用于描述逻辑上是否已经删除，就在它对应的属性isDeleted上面添加该注解</td> <td></td></tr></tbody></table> <h4 id="分页插件"><a href="#分页插件" class="header-anchor">#</a> 分页插件</h4> <p>使用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>页码<span class="token punctuation">,</span> 每页的记录数<span class="token punctuation">)</span><span class="token punctuation">;</span>

mapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Page中有分页相关的属性，如total、size、current和当前页的记录records</p> <h3 id="_7-mapstruct"><a href="#_7-mapstruct" class="header-anchor">#</a> 7. MapStruct</h3> <p>使用：</p> <p>① 引入依赖</p> <p>② 定义转化器接口</p> <p>转化器接口中的方法定义格式</p> <table><thead><tr><th>返回值类型</th> <th>方法名</th> <th>形参</th></tr></thead> <tbody><tr><td>目标类A</td> <td>bPO2DTO</td> <td>待转化类名B 变量名b</td></tr></tbody></table> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Mapper</span><span class="token punctuation">(</span>componentModel <span class="token operator">=</span> <span class="token string">&quot;spring&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserConverter</span> <span class="token punctuation">{</span>
    <span class="token comment">//目标类 方法名      待转化类</span>
    <span class="token class-name">UserDTO</span> <span class="token function">userPO2DTO</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><table><thead><tr><th>分类</th> <th>转化方法定义</th></tr></thead> <tbody><tr><td>PO和DTO的属性个数和名称都相同</td> <td>不用写@Mapping注解</td></tr> <tr><td>不同属性名的映射</td> <td>使用@Mapping注解，其中source属性写PO中的属性名，target写DTO中的属性名</td></tr> <tr><td>多个不同类型源对象的转化</td> <td>形参中传入这几个数据源，source部分使用对象名.参数名，target使用属性名</td></tr> <tr><td>转化复杂对象</td> <td>类似于深克隆，需要转化的对象的成员变量中有引用型变量，就需要为该类型定义一个转化方法，然后在转化的外层对象过程中会自动调用该成员变量对应的转化方法</td></tr> <tr><td>转化List</td> <td>先定义List<T>中的类型T的转化方法，然后在定义一个List的转化方法</T></td></tr></tbody></table> <p>多个不同类型源对象的转化举例：</p> <p>任务：Student、User转化成StudentMember</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Mapper</span><span class="token punctuation">(</span>componentModel <span class="token operator">=</span> <span class="token string">&quot;spring&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StudentMemberConverter</span> <span class="token punctuation">{</span>

    <span class="token comment">//数据来自多个对象的话，使用对象名.属性名指定source</span>
    <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">&quot;student.name&quot;</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">&quot;student.age&quot;</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">&quot;age&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">&quot;student.school&quot;</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">&quot;school&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">&quot;user.address&quot;</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">&quot;address&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">StudentMemberDTO</span> <span class="token function">studentPO2DTO</span><span class="token punctuation">(</span><span class="token class-name">Student</span> student<span class="token punctuation">,</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>③ 使用定义的转化器接口</p> <h3 id="_8-springboot"><a href="#_8-springboot" class="header-anchor">#</a> 8. SpringBoot</h3> <h4 id="常用的注解和配置"><a href="#常用的注解和配置" class="header-anchor">#</a> 常用的注解和配置</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableDiscoveryClient</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">&quot;com.cskaoyan.mall&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@EnableFeignClients</span>
<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">&quot;com.cskaoyan.mall.product.mapper&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="整合框架"><a href="#整合框架" class="header-anchor">#</a> 整合框架</h4> <p>starter依赖</p> <p>通常在SpringBoot中要使用某一项技术，只需要引入其starter依赖就可以了。</p> <p>SpringBoot官方提供的依赖一般叫：spring-boot-starter-xxx</p> <p>例如：spring-boot-starter-web</p> <p>第三方提供的依赖一般名叫：xxx-spring-boot-starter</p> <p>例如：mybatis-spring-boot-starter</p> <h4 id="约定大于配置"><a href="#约定大于配置" class="header-anchor">#</a> 约定大于配置</h4> <p>在使用SpringBoot之前大量的配置是一件很麻烦的事，使用SpringBoot之后，SpringBoot提供了大量的默认配置，比如说如何连接数据库、如何设置web服务器、如何处理日志文件等。我们不需要手动配置这些，因为框架已经做了这些决策。</p> <p>在SpringBoot项目中我们还可以直接接管配置，也可以对配置进行补充</p> <p>以整合SpringMVC为例，在配置类</p> <ul><li>如果使用@EnableWebMVC意味着全面接管SpringMVC的相关配置，默认配置无效。</li> <li>如果使用@Configuration意味着是对默认配置的补充。</li></ul> <h3 id="_9-springcloud"><a href="#_9-springcloud" class="header-anchor">#</a> 9. SpringCloud</h3> <h4 id="微服务设计优势和原则"><a href="#微服务设计优势和原则" class="header-anchor">#</a> 微服务设计优势和原则</h4> <p><a href="https://changjishun.github.io/blog/skills/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html" target="_blank" rel="noopener noreferrer">https://changjishun.github.io/blog/skills/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="openfeign简化服务间的调用"><a href="#openfeign简化服务间的调用" class="header-anchor">#</a> OpenFeign简化服务间的调用</h4> <p><strong>详细步骤</strong></p> <p>① 添加依赖</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>② 定义用来调用用户服务的OpenFeign接口</p> <p>在该接口中将你需要调用的服务的方法“原封不动”的复制到接口中，方法名可以不同。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">&quot;user-service&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserFeignClient</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user/address/{id}&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>③ 在启动类上面添加注解@EnableFeignClients</p> <p>④ 调用服务，使用上面定义的接口，通过调用上面接口的方法完成服务调用。</p> <p><strong>如果不使用OpenFeign的话，我们自己发送请求就会非常麻烦</strong></p> <p>① 使用discoveryClient.getInstance(&quot;服务名称&quot;)从注册中心获取该服务的服务集群信息。</p> <p>② 获取一个服务实例的地址，然后拼接url。</p> <p>③ 使用restTemplate发送http请求。</p> <h4 id="nacos服务注册中心"><a href="#nacos服务注册中心" class="header-anchor">#</a> Nacos服务注册中心</h4> <p><strong>使用步骤</strong></p> <p><strong>服务端使用</strong></p> <p>① 下载好Nacos安装包，使用命令行启动nacos服务器</p> <p><strong>客户端使用</strong></p> <p>① 添加依赖</p> <p>② 添加配置</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
	<span class="token key atrule">cloud</span><span class="token punctuation">:</span>
		<span class="token key atrule">nacos</span><span class="token punctuation">:</span>
			<span class="token key atrule">discovery</span><span class="token punctuation">:</span>
				<span class="token comment"># nacos服务器地址</span>
				<span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
</code></pre></div><p>③ 在启动类添加注解@EnableDiscoveryClient</p> <p>微服务是分布式架构的一种实现方式。为服务是分布式系统的独立运行单元。每个服务都有自己的数据库和业务逻辑，每个微服务都可以独立开发、测试、部署和扩展。</p> <h4 id="nacos配置中心的使用"><a href="#nacos配置中心的使用" class="header-anchor">#</a> Nacos配置中心的使用</h4> <p><strong>Profile配置</strong></p> <p>是每个服务自己的配置</p> <p>① 每个服务自己的配置在nacos配置中心配置集的id(即data-id)满足下面的格式：（在nacos服务端网页“配置管理”中配置）</p> <div class="language- extra-class"><pre class="language-text"><code>${prefix}-${spring.profiles.active}.${file-extension}
</code></pre></div><ul><li><code>prefix</code>默认为spring.application.name的值（应用名称）</li> <li><code>spring.profiles.active</code>为当前环境对应的profile（</li> <li><code>file-extension</code>为配置内容的数据格式。目前只支持properties和yml</li></ul> <p>举例：</p> <p>应用名称为：user-service</p> <p>环境为：dev</p> <p>文件格式：yaml</p> <div class="language- extra-class"><pre class="language-text"><code>user-service-dev.yaml
</code></pre></div><p>② 添加nacos配置中心依赖</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>③ 在resources目录下添加bootstrap.yml配置文件</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service
  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>
    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">config</span><span class="token punctuation">:</span>
        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml
        <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
        <span class="token comment">#group: DEV_GROUP</span>
        <span class="token comment">#namespace: b6d9c7c0-8189-4050-a83f-8bff345c0157</span>
        <span class="token comment"># 可以指定多个共享配置的配置集</span>
        <span class="token key atrule">shared-configs</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">data-id</span><span class="token punctuation">:</span> common.yaml
            <span class="token key atrule">group</span><span class="token punctuation">:</span> SHARED_GROUP
            <span class="token key atrule">refresh</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token comment"># ${prefix}-${spring.profiles.active}.${file-extension}</span>
<span class="token comment"># user-service-dev.yaml</span>
<span class="token comment"># user-service-test.yaml</span>
</code></pre></div><p>④ 测试</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/config&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;${nacos.config}&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span> profile<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/profile&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">profileConfigTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> profile<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>共享配置</strong></p> <p>只要data-id不是按profile（服务自己的配置）的配置的data-id的格式写的，就是共享配置。</p> <p><strong>Nacos配置的持久化</strong></p> <p>Nacos有一个自带的数据库derby，Nacos也支持mysql数据库。</p> <p>将数据库改为MySql数据库</p> <p>① 在数据库中创建一个名为nacos的数据库</p> <p>② 在nacos数据库中执行数据库初始化文件(该文件在nacos的conf目录下)</p> <p>③ 修改conf/application.properties文件，增加mysql数据源的设置，设置数据源的url、用户名、密码等信息。</p> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token key attr-name">spring.datasource.platform</span><span class="token punctuation">=</span><span class="token value attr-value">mysql</span>
<span class="token key attr-name">db.num</span><span class="token punctuation">=</span><span class="token value attr-value">1</span>
<span class="token comment"># 这里的url要改成你自己的mysql数据库地址，并在你的mysql中创建名为nacos的数据库</span>
<span class="token key attr-name">db.url.0</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mysql://localhost:3306/nacos?</span>
<span class="token key attr-name">characterEncoding</span><span class="token punctuation">=</span><span class="token value attr-value">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span>
<span class="token comment"># 这里要改成你自己登录mysql的用户名和密码</span>
<span class="token key attr-name">db.user.0</span><span class="token punctuation">=</span><span class="token value attr-value">nacos_devtest</span>
<span class="token key attr-name">db.password.0</span><span class="token punctuation">=</span><span class="token value attr-value">youdontknow</span>
</code></pre></div><h4 id="ribbon负载均衡策略"><a href="#ribbon负载均衡策略" class="header-anchor">#</a> Ribbon负载均衡策略</h4> <table><thead><tr><th>策略</th> <th>实现类</th> <th>描述</th></tr></thead> <tbody><tr><td>随机策略</td> <td>RandomRule</td> <td>随机选择server</td></tr> <tr><td>轮训策略</td> <td>RoundRobinRule</td> <td>轮询选择</td></tr> <tr><td>重试策略</td> <td>RetryRule</td> <td>对选定的负载均衡策略(轮训)之上的重试机制，在一个配置时间段内当选择服务不成功，则一直尝试使用该策略选择一个可用的服务；</td></tr> <tr><td>最低并发策略</td> <td>BestAvailableRule</td> <td>逐个考察服务，如果服务断路器打开，则忽略，再选择其中并发连接最低的服务</td></tr> <tr><td>可用过滤策略</td> <td>AvailabilityFilteringRule</td> <td>过滤掉因一直失败并被标记为circuit tripped的服务，过滤掉那些高并发链接的服务（active connections超过配置的阈值)</td></tr> <tr><td>响应时间加权重策略</td> <td>WeightedResponseTimeRule</td> <td>根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td></tr> <tr><td>区域权重策略</td> <td>ZoneAvoidanceRule</td> <td>综合判断服务所在区域的性能，和服务的压力，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server</td></tr></tbody></table> <h3 id="_10-elasticsearch"><a href="#_10-elasticsearch" class="header-anchor">#</a> 10. ElasticSearch</h3> <h4 id="ik分词器"><a href="#ik分词器" class="header-anchor">#</a> IK分词器</h4> <p>Ik分词器有两种模式：ik_max_word和ik_smart</p> <p>ik_max_word模式会将文本做最细粒度的拆分</p> <p>ik_smart会做最粗粒度的拆分</p> <h4 id="elasticsearch介绍"><a href="#elasticsearch介绍" class="header-anchor">#</a> ElasticSearch介绍</h4> <p>Elastic Saerch是一个分布式全文搜索引擎，是一种文档数据库。</p> <p>它和关系型数据库一样需要存储一条条记录(数据)，与关系型数据库不同的地方是<strong>索引</strong>[^1]组织的方式和查询记录的方式。elasticsearch使用倒排索引来查询数据。</p> <p>ElasticSearch基于C/S架构，默认端口号9200，它的操作都是使用http请求完成。</p> <p>基本概念</p> <ul><li>字段(Field)：类似于关系型数据库中的字段</li> <li>文档(document)：类似于关系型数据库中的一行记录</li> <li>映射(mapping)：类似于关系型数据库中的表结构定义</li> <li>索引(index)：类似于关系型数据库中的数据库概念</li> <li>类型(Type)：类似于关系型数据库中的表</li></ul> <h4 id="倒排索引"><a href="#倒排索引" class="header-anchor">#</a> 倒排索引</h4> <p>此处所说的索引是用于快速访问数据的数据结构</p> <p>正排</p> <p>根据document找它包含的关键词</p> <p>倒排</p> <p>根据关键字找包含这个关键词的document。</p> <p><strong>添加索引</strong>：数据(document)在添加时，会针对字符串类型的字段创建索引。具体的方式是，将字符串类型的字段进行<strong>分词</strong>，然后以这些分出来的关键词为key，value部分存储包含这个关键词的document的id。</p> <h4 id="常见的查询方式"><a href="#常见的查询方式" class="header-anchor">#</a> 常见的查询方式</h4> <table><thead><tr><th>查询方式</th> <th></th></tr></thead> <tbody><tr><td>match_all</td> <td></td></tr> <tr><td>match</td> <td></td></tr> <tr><td>term</td> <td></td></tr> <tr><td>querystring</td> <td></td></tr> <tr><td>范围、排序查询</td> <td></td></tr> <tr><td>bool复合查询</td> <td></td></tr> <tr><td>聚合查询</td> <td>指标聚合：类似于MySQL的聚合函数。有max、min、avg、sum等。桶聚合：相当于MySQL的group by操作。不要对text类型的字段进行分组，会失败。&quot;操作类型&quot;为terms</td></tr> <tr><td>高亮查询</td> <td></td></tr></tbody></table> <h3 id="_11-minio"><a href="#_11-minio" class="header-anchor">#</a> 11. MinIO</h3> <p>MinIO是Apache开源的对象存储服务器，非常适合存储大容量非结构化数据、例如图片、视频、日志文件等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</p> <p>MinIO有如下特征</p> <table><thead><tr><th>特征</th> <th>描述</th></tr></thead> <tbody><tr><td>高性能</td> <td>可达到55GB/s的读速率、35GB/s的写速率</td></tr> <tr><td>可扩容</td> <td>不同的MinIo集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心</td></tr> <tr><td>SDK支持</td> <td>它有Java、Python、Go等语言的SDK支持</td></tr> <tr><td>支持纠删码</td> <td>MinIO使用纠删码、Checksum来防止硬件错误和静默数据源污染。在最高冗余度配置下，即使丢失1/2的磁盘也能恢复数据</td></tr> <tr><td>有控制台界面</td> <td></td></tr> <tr><td>功能简单</td> <td>这一设计原则使得MinIO不容易出错、更快启动</td></tr></tbody></table> <h3 id="_12-rocketmq"><a href="#_12-rocketmq" class="header-anchor">#</a> 12. RocketMQ</h3> <h4 id="与其他消息度列的对比"><a href="#与其他消息度列的对比" class="header-anchor">#</a> 与其他消息度列的对比</h4> <table><thead><tr><th>消息中间件</th> <th>优点</th> <th>不足</th></tr></thead> <tbody><tr><td>RocketMQ</td> <td>经历过世界上绝无仅有的高并发的实战的考验(双十一)</td> <td>社区不够活跃</td></tr> <tr><td>ActiveMQ</td> <td>主要使用场景就是解耦和异步调用。</td> <td>没经过大规模吞吐量场景的验证，开源社区不活跃</td></tr> <tr><td>RabbitMQ</td> <td>使用erlang开发，队列基于内存，高并发低延迟。</td> <td>开发语言小众，不利于自己基于源码开发扩展，遇到bug调试起来比较麻烦</td></tr> <tr><td>Kafka</td> <td>可以实时的处理大量的数据，比如基于hadoop的批处理系统</td> <td>消费失败不支持重试，支持消息顺序，但是一台代理宕机后就会产生消息乱序</td></tr></tbody></table> <h4 id="生产者发送消息"><a href="#生产者发送消息" class="header-anchor">#</a> 生产者发送消息</h4> <p>① 创建一个生产者对象DefaultMQProducer(构造器要传入生产者组名)</p> <p>② 给生产者对象设置nameserver的ip地址</p> <p>③ 启动生产者(使用start方法)</p> <p>④ 创建消息Message对象</p> <p>⑤ 使用setTopic()给消息对象设置topic，使用setBody()设置消息内容(消息内容为byte[]类型，字符串消息需要使用字符串的getBytes(Charset.forName(&quot;utf-8&quot;))获取)</p> <p>⑥ 使用producer的send方法发送消息</p> <h4 id="消费者接收消息"><a href="#消费者接收消息" class="header-anchor">#</a> 消费者接收消息</h4> <p>① 创建一个消费者对象DefaultMQPushConsumer(需要指定消费者组名)</p> <p>② 设置nameserver地址</p> <p>③ 订阅主题(使用subscribe方法)</p> <p>④ 设置消息监听器 (使用setMessageListener()，参数为匿名内部类对象，用于指定收到消息后如何处理消息)。</p> <p>⑤ 实现监听器的匿名内部类对象的的方法</p> <p>⑥ 启动consumer，使用consumer的start方法</p> <h4 id="延迟消息"><a href="#延迟消息" class="header-anchor">#</a> 延迟消息</h4> <p>只需要给生产者发送的消息对象设置延时就行了</p> <p>设置的延时时间是延时的级别，不同的延时级别对应不同的延时时间。</p> <h2 id="项目介绍"><a href="#项目介绍" class="header-anchor">#</a> 项目介绍</h2> <p>在这个项目中，我参与了母婴商城的开发，主要负责商品详情和搜索服务的开发。以下是我在项目中的一些关键技术点和工作职责：</p> <ol><li><strong>商品详情缓存</strong>：为了提高商品数据的访问速度，我使用了Redis作为缓存存储，并利用Spring的AOP和自定义注解定义切点，实现了对商品数据的缓存。这样，在用户请求商品详情时，首先会检查Redis中是否存在缓存，如果存在则直接返回缓存数据，提高了响应速度。</li> <li><strong>搜索功能</strong>：为了实现高效的商品搜索，我使用了Elasticsearch作为文档数据库。通过对商品的各种搜索条件建立索引，实现了快速的全文检索功能。用户可以根据关键字、分类、价格等条件进行商品搜索，并得到相关的搜索结果。</li> <li><strong>缓存预热</strong>：为了避免缓存冷启动的问题，我使用了Redis缓存预热的技术。通过定时任务和缓存预热策略，提前将热门商品的数据加载到缓存中，减少了用户请求时的数据查询时间，提高了系统的性能和用户体验。</li> <li><strong>非结构化数据存储</strong>：为了提高图片等非结构化数据的存储和访问效率，我使用了MinIO对象存储服务器。通过MinIO，我们可以将图片等数据以对象的形式存储，并通过获取对象的URL进行访问，提高了数据的访问效率和可靠性。</li> <li><strong>数据同步</strong>：为了保持数据的一致性，我使用了RocketMQ的消息队列实现了商品的上下架时Elasticsearch和MySQL的数据同步。当商品上下架时，系统会将相应的消息发送到RocketMQ，然后由消费者监听消息并进行相应的数据同步操作，确保Elasticsearch和MySQL中的数据保持一致性。</li></ol> <p>以上是我在母婴商城项目中的部分工作内容和技术要点。通过这个项目，我熟悉了Spring、SpringMVC、SpringBoot和Mybatis-Plus等技术栈，同时也获得了在分布式系统和电子商务领域的实际经验。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/skills/面试/面经.html" class="prev">
        面经
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.e95f8842.js" defer></script><script src="/blog/assets/js/3.08356745.js" defer></script><script src="/blog/assets/js/54.c7097067.js" defer></script>
  </body>
</html>
