(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{477:function(n,a,t){"use strict";t.r(a);var v=t(14),_=Object(v.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[n._v("#")]),n._v(" 内部类")]),n._v(" "),a("p",[n._v("内部类的分类")]),n._v(" "),a("ol",[a("li",[n._v("成员内部类")]),n._v(" "),a("li",[n._v("静态内部类")]),n._v(" "),a("li",[n._v("局部内部类")]),n._v(" "),a("li",[n._v("匿名内部类")]),n._v(" "),a("li",[n._v("lambda表达式")])]),n._v(" "),a("h2",{attrs:{id:"一、-成员内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、-成员内部类"}},[n._v("#")]),n._v(" 一、 成员内部类")]),n._v(" "),a("ol",[a("li",[n._v("访问修饰符：四种访问修饰级别都可以。")]),n._v(" "),a("li",[n._v("成员特点：\n(1) 成员内部类的对象必须在外围类的对象的基础上才能得到，想要得到内部类对象，就要先创建外围类。\n(2) 成员内部类没有静态声明。没有静态成员变量、静态成员方法，其他和普通子类一样。")]),n._v(" "),a("li",[n._v("访问特点：\n"),a("strong",[n._v("(1) 在成员内部类中访问外围类成员")]),n._v("（访问不受限制）\n直接访问。因为成员内部类对象拥有外围类对象的引用作为成员变量。\n"),a("strong",[n._v("(2) 在外围类中访问成员内部类成员")]),n._v("（访问不受限制）\nI. 在外围类的静态上下文中访问成员内部类成员\n没有任何对象，需要先创建外围类的对象，然后在外围类的基础上创建成员内部类的对象。\n"),a("code",[n._v("InnerClazz ic = new EnclosedClazz().new InnerClazz();")]),n._v("\nII. 在外围类的非静态上下文中访问成员内部类成员\n拥有外围类对象，只需要创建成员内部类即可。\n"),a("strong",[n._v("(3) 在外部类中访问成员内部类成员")]),n._v("（访问受限制）\n无论是静态上下文还是非静态上下文都没有该成员内部类对象，需要先创建外围类对象，然后再在外围类对象的基础上创建成员内部类对象。\n"),a("code",[n._v("EnclosedClazz.InnerClazz ic = new EnclosedClazz().new InnerClazz();")])])]),n._v(" "),a("h2",{attrs:{id:"二、-静态内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、-静态内部类"}},[n._v("#")]),n._v(" 二、 静态内部类")]),n._v(" "),a("p",[n._v("静态内部类和外围类之间的访问都不受权限的限制，没有任何依赖关系，想要访问就创建各自对象即可。")]),n._v(" "),a("ol",[a("li",[a("p",[n._v("访问修饰符：四种访问修饰级别都可以。")])]),n._v(" "),a("li",[a("p",[n._v("成员特点：\n和普通类没有区别。")])]),n._v(" "),a("li",[a("p",[n._v("访问特点：\n"),a("strong",[n._v("(1) 在静态内部类中访问外围类成员")]),n._v("（访问不受限制）\n创建外围类对象。")]),n._v(" "),a("p",[a("strong",[n._v("(2) 在外围类中访问静态内部类成员")]),n._v("（访问不受限制）\n创建静态内部类对象。")]),n._v(" "),a("p",[a("strong",[n._v("(3) 在外部类中访问成员内部类成员")]),n._v("（访问受限制）\n直接创建静态内部类对象\n"),a("code",[n._v("EnclosedClazz.NestedClazz nc = new EnclosedClazz.NestedClazz();")])])])]),n._v(" "),a("h2",{attrs:{id:"三、-局部内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、-局部内部类"}},[n._v("#")]),n._v(" 三、 局部内部类")]),n._v(" "),a("ol",[a("li",[a("p",[n._v("访问权限修饰符：类似局部变量没有访问权限的概念。")])]),n._v(" "),a("li",[a("p",[n._v("成员特点：\n和成员内部类完全一致，没有静态声明，可以定义用字面值常量赋值的"),a("strong",[n._v("全局常量")]),n._v("（作用域的变量作为常量，事实常量）。")]),n._v(" "),a("blockquote",[a("p",[n._v("该变量在作用域的其他使用场景也是作为常量吗？还是说只在内部类中作为常量。")])])]),n._v(" "),a("li",[a("p",[n._v("访问特点：\n"),a("strong",[n._v("(1) 局部内部类访问外围类")]),n._v("\nI. 局部内部类在静态上下文中\n需要创建外围类对象\nII.局部内部类在非静态上下文中\n可以直接调用外围类成员\n"),a("strong",[n._v("(2) 外围内部类访问局部内部类")]),n._v("\n受作用域的限制，必须在作用区内部才能访问局部内部类，创建对象。")])]),n._v(" "),a("li",[a("p",[n._v("继承和实现")])])]),n._v(" "),a("h2",{attrs:{id:"四、-匿名内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、-匿名内部类"}},[n._v("#")]),n._v(" 四、 匿名内部类")]),n._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[n._v("语法"),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 局部位置")]),n._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("new")]),n._v(" 类名或者接口名"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 某类名或接口名的子类的类体")]),n._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v("*")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 局部位置")]),n._v("\n")])])]),a("ol",[a("li",[n._v("创建的是“类名或接口名”的子类对象，该子类名字不知道，所以叫匿名内部类。")]),n._v(" "),a("li",[n._v("“{}”中可以重写父类的方法，也可以定义自己的方法。")]),n._v(" "),a("li",[n._v("使用方法\n(1) 直接作为对象使用。\n(2) 用“类名或接口名”中的父类或接口类型引用接收该对象。")]),n._v(" "),a("li",[n._v("匿名内部类不能定义构造器，因为类名是匿名的，写不出构造器。但是匿名类任然有编译器默认提供的无参构造器。")]),n._v(" "),a("li",[n._v('当匿名内部类创建的是一个类的对象时\n"()"可以给父类构造器传参\n当创建的是接口的子类对象时\n"()"就没有用了。')]),n._v(" "),a("li",[n._v("匿名内部类访问作用域内部的局部变量,"),a("strong",[n._v("该局部变量是常量")]),n._v("\n该变量在作用域的其他使用场景也是作为常量吗？还是说只在内部类中作为常量。")]),n._v(" "),a("li",[n._v("用途\n(1) 作为返回值\n(2) 作为形式参数")])]),n._v(" "),a("h2",{attrs:{id:"五、-lambda表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、-lambda表达式"}},[n._v("#")]),n._v(" 五、 lambda表达式")]),n._v(" "),a("blockquote",[a("p",[n._v("lambda表达式是Java8的一个新特性，可以取代接口的匿名内部类，写出更简洁的代码。")])]),n._v(" "),a("ol",[a("li",[n._v("语法和基本使用")])]),n._v(" "),a("p",[n._v("形参列表：强制子类实现的抽象方法的形参列表\n“{}”：重写抽象方法的方法体。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("能够用lambda表达式创建子类对象的接口必须是功能接口(FunctionalInterface)\n> 功能接口的概念：\n> 指的是接口中，有且仅有一个强制子类实现的抽象方法的接口。、\n\n功能接口只有一个方法吗？只有一个抽象方法吗？\n    (1) 功能接口中可以有默认方法和静态方法。\n    (2) 如果一个抽象方法可以用Object类的某个方法作为默认实现，那么该抽象方法就不会强制子类实现。\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[n._v("类型推断的方式\n(1) 直接用父类接口引用接收\n(2) 类似于强制类型转换\n((接口的名字) lambda表达式)")]),n._v(" "),a("p",[n._v("(3) 借助形参的数据类型（lambda表达式作为参数）\n(4) 借助方法的返回值类型（lambda表达式作为返回值）")])]),n._v(" "),a("li",[a("p",[n._v('简化\n(1) "(形参列表)"中的形式参数数据类型可以省略。\n(2) “{}” 如果重写的方法体只有一条语句，就可以省略，如果这一句是return语句，可以直接省略return。\n(3) 方法引用\n用一个已经实现的方法作为lambda表达式抽象方法的实现\nI. 返回值类型\n功能接口中的抽象方法的\n返回值类型是void或基本数据类型，必须保持一致。\n返回值类型是引用数据类型，可以保持一致和返回它的子类。\nII.调用格式：不省略“->”\n(形参列表) -> 已实现方法的调用(形参列表);\nIII.调用格式：省略“->”\n已实现方法的归属者:: 已实现的方法的方法名;\n已实现方法的归属者：静态方法属于类，成员方法属于对象')])])])])}),[],!1,null,null,null);a.default=_.exports}}]);